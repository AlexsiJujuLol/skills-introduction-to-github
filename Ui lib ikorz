local Stats = game:GetService("Stats")
local Players = game:GetService("Players")
local VirtualInputManager = game:GetService("VirtualInputManager")
local RunService = game:GetService("RunService")

local local_player = Players.LocalPlayer or Players.PlayerAdded:Wait()
local PingBased = true
local PingBasedOffset = 0.05
local MinDistanceToParry = 0.3
local MaxDistanceToParry = 1.5
local ParryDelay = 0.015
local MinimumBallVelocity = 10
local ParryCooldown = 0.1
local lastParryTime = 0
local lastCheckTime = 0
local canParry = true
local isParrying = false
local lastBallVelocity = 0
local lastBallPosition = nil

local function resolve_parry_Remote()
    for _, service in pairs({game:GetService("AdService"), game:GetService("SocialService")}) do
        local temp_remote = service:FindFirstChildOfClass("RemoteEvent")
        if temp_remote and temp_remote.Name:find("\n") then
            parry_remote = temp_remote
            break
        end
    end
end

local function FindBall()
    for _, ball in pairs(workspace:WaitForChild("Balls"):GetChildren()) do
        if ball:GetAttribute("realBall") == true then
            return ball
        end
    end
end

local function IsTheTarget()
    return local_player.Character and local_player.Character:FindFirstChild("Highlight")
end

local function DetectBallCurve(ball)
    local ballPosition = ball.Position
    local ballVelocity = ball.AssemblyLinearVelocity
    local speed = ballVelocity.Magnitude

    if lastBallPosition then
        local deltaPos = ballPosition - lastBallPosition
        local velocityDirection = ballVelocity.Unit
        local angle = math.acos(velocityDirection:Dot(deltaPos.Unit)) * (180 / math.pi)

        if angle > 10 then -- Threshold for detecting curve
            return true
        end
    end

    lastBallPosition = ballPosition
    lastBallVelocity = ballVelocity

    return false
end

local function PerformParry()
    if tick() - lastParryTime >= ParryCooldown and canParry and not isParrying then
        isParrying = true
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0)
        lastParryTime = tick()
        task.delay(ParryCooldown, function()
            canParry = true
            isParrying = false
        end)
    end
end

task.spawn(function()
    RunService.Heartbeat:Connect(function()
        if tick() - lastCheckTime >= ParryDelay then
            local Ball = FindBall()
            if Ball then
                local BallPosition = Ball.Position
                local BallVelocity = Ball.AssemblyLinearVelocity.Magnitude
                local Distance = local_player:DistanceFromCharacter(BallPosition)

                local Ping = Stats.Network.ServerStatsItem["Data Ping"]:GetValue()
                local PingAdjustment = Ping / 1000
                local DynamicPingOffset = PingAdjustment * 0.5
                local DynamicParryDistance = MinDistanceToParry + DynamicPingOffset

                if DynamicParryDistance < MinDistanceToParry then
                    DynamicParryDistance = MinDistanceToParry
                elseif DynamicParryDistance > MaxDistanceToParry then
                    DynamicParryDistance = MaxDistanceToParry
                end

                local ballIsCurved = DetectBallCurve(Ball)

                if BallVelocity > MinimumBallVelocity and (Distance / BallVelocity) <= DynamicParryDistance and IsTheTarget() then
                    if ballIsCurved then
                        -- Adjust parry timing for curved balls
                        ParryDelay = 0.02
                    else
                        ParryDelay = 0.015
                    end
                    PerformParry()
                end
            end

            lastCheckTime = tick()
        end
    end)
end)

resolve_parry_Remote()