local Stats = game:GetService("Stats")
local Players = game:GetService("Players")
local VirtualInputManager = game:GetService("VirtualInputManager")
local RunService = game:GetService("RunService")

local local_player = Players.LocalPlayer or Players.PlayerAdded:Wait()
local PingBased = true
local PingBasedOffset = 0.05
local MinDistanceToParry = 0.3
local MaxDistanceToParry = 1.5
local ParryDelay = 0.015
local MinimumBallVelocity = 10
local ParryCooldown = 0.1
local lastParryTime = 0
local lastCheckTime = 0
local canParry = true
local isParrying = false
local lastBallVelocity = 0
local lastBallPosition = nil

local function resolve_parry_Remote()
    for _, service in pairs({game:GetService("AdService"), game:GetService("SocialService")}) do
        local temp_remote = service:FindFirstChildOfClass("RemoteEvent")
        if temp_remote and temp_remote.Name:find("\n") then
            parry_remote = temp_remote
            break
        end
    end
end

local function FindBall()
    for _, ball in pairs(workspace:WaitForChild("Balls"):GetChildren()) do
        if ball:GetAttribute("realBall") == true then
            return ball
        end
    end
end

local function IsTheTarget()
    return local_player.Character and local_player.Character:FindFirstChild("Highlight")
end

-- Ball Prediction Function
local function PredictBallPosition(Ball, timeAhead)
    local ballVelocity = Ball.AssemblyLinearVelocity
    local predictedPosition = Ball.Position + ballVelocity * timeAhead
    return predictedPosition
end

-- Detecting Curved Ball
local function DetectBallCurveAndAdjustPrediction(Ball)
    local ballPosition = Ball.Position
    local ballVelocity = Ball.AssemblyLinearVelocity
    local speed = ballVelocity.Magnitude

    if lastBallPosition then
        local deltaPos = ballPosition - lastBallPosition
        local velocityDirection = ballVelocity.Unit
        local angle = math.acos(velocityDirection:Dot(deltaPos.Unit)) * (180 / math.pi)

        if angle > 10 then -- Threshold for detecting curve
            local predictedPosition = PredictBallPosition(Ball, 0.1) -- Predict where the ball will be in 0.1 seconds
            -- Adjust parry based on prediction
            return true, predictedPosition
        end
    end

    lastBallPosition = ballPosition
    lastBallVelocity = ballVelocity

    return false, ballPosition
end

local function ShouldPerformParry(Distance, BallVelocity, DynamicParryDistance)
    -- Only perform a parry if the ball is within the valid range, moving fast enough, and the time allows for it
    return (BallVelocity > MinimumBallVelocity) and (Distance <= DynamicParryDistance) and
           (tick() - lastParryTime >= CalculateDynamicParryDelay(Stats.Network.ServerStatsItem["Data Ping"]:GetValue(), false))
end

local function PerformParry()
    if tick() - lastParryTime >= ParryCooldown and canParry and not isParrying then
        isParrying = true
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0)
        lastParryTime = tick()
        task.delay(ParryCooldown, function()
            canParry = true
            isParrying = false
        end)
    end
end

task.spawn(function()
    RunService.Heartbeat:Connect(function()
        if tick() - lastCheckTime >= ParryDelay then
            local Ball = FindBall()
            if Ball then
                local BallPosition = Ball.Position
                local BallVelocity = Ball.AssemblyLinearVelocity.Magnitude
                local Distance = local_player:DistanceFromCharacter(BallPosition)

                local Ping = Stats.Network.ServerStatsItem["Data Ping"]:GetValue()
                local PingAdjustment = Ping / 1000
                local DynamicPingOffset = PingAdjustment * 0.5
                local DynamicParryDistance = MinDistanceToParry + DynamicPingOffset

                if DynamicParryDistance < MinDistanceToParry then
                    DynamicParryDistance = MinDistanceToParry
                elseif DynamicParryDistance > MaxDistanceToParry then
                    DynamicParryDistance = MaxDistanceToParry
                end

                local ballIsCurved, predictedPosition = DetectBallCurveAndAdjustPrediction(Ball)

                if ShouldPerformParry(Distance, BallVelocity, DynamicParryDistance) then
                    if ballIsCurved then
                        -- Adjust parry timing for curved balls
                        ParryDelay = 0.02
                    else
                        ParryDelay = 0.015
                    end
                    -- Perform Parry with adjusted logic
                    PerformParry()
                end
            end

            lastCheckTime = tick()
        end
    end)
end)

resolve_parry_Remote()